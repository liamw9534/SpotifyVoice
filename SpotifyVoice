#!/usr/bin/python -B

"""
SpotifyVoice

Voice controlled command-line spotify music player using voice
recognition.

Copyright (c) 2014 All Right Reserved, Liam Wickins

Please see the LICENSE file for more information.

THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.
"""

from __future__ import division
import sys, time, readline, os, threading, codecs
from optparse import OptionParser
from MusicDB import MusicDB

parser = OptionParser()
parser.add_option("-u", "--user", dest="user",
                  help="Spotify user name",
                  action="store", type="string")
parser.add_option("-p", "--pass", dest="password",
                  help="Spotify password",
                  action="store", type="string")
parser.add_option("-q", "--quiet", dest="announce",
                  help="Synthesizer announcements are suppressed",
                  action="store_false", default=True)
parser.add_option("-d", "--db", dest="musicDatabase",
                  help="Music database",
                  action="store", type="string")
parser.add_option("-a", "--asr", dest="asrDatabase",
                  help="ASR database for referencing music corpus",
                  action="store", type="string")
parser.add_option("-m", "--model", dest="model",
                  help="ASR model from database to use",
                  action="store", type="string")
(options, args) = parser.parse_args()


# Required for local imported python modules
sys.path.append("../ASRUtils")
sys.path.append("../espeak.py")

from SpotifyService import SpotifyService
from MusicOutcome import MusicOutcome
from SpotifySearch import SpotifySearch
from PlayQueue import PlayQueue
from ASRModel import ASRModel
from ASR import ASR
from ASRGoogleAPI import ASRGoogleAPI
from TextToSpeech import TextToSpeech

if (not options.user or not options.password):
  print "You must have a Spotify account and token to use this program."
  exit()

if (not options.asrDatabase or not options.model):
  print "You have not given a local ASR model - using Google ASR instead"

class MusicASR():

  def __init__(self, database, model):

    if (database and model):
      self.asrModel = ASRModel(database, model)
      self.asrInst = ASR(self.__AsrCallback,
                         hmm=self.__GetHmm(),
                         lm=self.__GetLm(),
                         dic=self.__GetDict())
    else:
      self.asrInst = ASRGoogleAPI(self.__AsrCallback, timeout=1)

    # Start ASR instance listening
    self.asrInst.Play()

  def __AsrCallback(self, event, text, nbest):
    if (event == 'result'):
      self.best = text
      self.nbest = nbest
    else:
      self.asrTimeout = 2.0

  def WaitSpeechOutcome(self, timeout=2.0):

    # Wait for ASR message or timeout
    self.best = None
    self.nbest = None
    self.asrTimeout = timeout
    while self.asrTimeout > 0:
      time.sleep(0.1)
      self.asrTimeout -= 0.1
      if (self.best):
        break

    # Look at the best entry and quickly check if it's a command
    if (self.best):
      #print "*** Best: ", self.best, "N-Best:", self.nbest
      s = self.best
      p = 1.0
      try:
        if (s.startswith('COMMAND ')):
          # Strip off 'COMMAND' prefix since this is merely a 'cue'
          outcome = MusicOutcome(s.lower()[8:], confidence=p)
        else:
          outcome = MusicOutcome(s.lower(), confidence=p)
        if (outcome is not None):
          return outcome
      except:
        pass

    return None

  def __SearchASRModelCorpus(self):

    # Only process if we have nbest entries to look at
    res = {}
    if (self.nbest is not None):
      # Go through n-best options found by ASR and match them against
      # the music corpus loaded
      for i in self.nbest:
        if (i):
          # Favour options that match our database exactly from start first
          matches = self.asrModel.FindStartsWith(i)

          # Iterate through matches
          for id,s in matches:
            try:
              # Handle the outcome parsing
              p = len(i.split(' ')) / len(s.split(' '))
              if (s.startswith('COMMAND ')):
                # Strip off 'COMMAND' prefix since this is merely a 'cue'
                outcome = MusicOutcome(s.lower()[8:], confidence=p)
              else:
                outcome = MusicOutcome(s.lower(), confidence=p)
              if (outcome is not None):
                # Compute probability based on word count match, store outcome
                res[s] = { 'p':p, 'outcome':outcome }
                #return outcome
            except:
              pass

    # Get highest probability entry
    k = (None, 0)
    for i in res.keys():
      if (res[i]['p'] > k[1]):
        k = (res[i]['outcome'], res[i]['p'])

    if (len(res.keys()) > 0):
      print "Checked", len(res.keys()), "different outcomes..."

    return k[0]

  def Exit(self):
    self.asrInst.Exit()

  def __GetHmm(self):
    return self.asrModel.model

  def __GetLm(self):
    return self.asrModel.lm

  def __GetDict(self):
    return self.asrModel.dict

# Create client session and login
m = SpotifyService()
if (m.LoginUser(options.user, options.password) != 0):
  m.Exit()
  exit("Error: Failed to login to Spotify")

# Initialize our music ASR
asr = MusicASR(options.asrDatabase, options.model)

# Create offline music database connection
db = MusicDB(options.musicDatabase)

trackCount = 0
lastTrackCount = 0
def NewTrackIndication():
  global trackCount
  trackCount += 1

# Create play queue
pq = PlayQueue(m, NewTrackIndication)

# Create speech synthesizer
synth = TextToSpeech()

def UnicodeToAscii(u):
  table = { 0x2018:0x27, 0x2019:0x27, 0x201C:0x22, 0x201D:0x22 }
  return u.translate(table).encode('ascii', 'ignore')

# Helper function to announce/show current track information
def TrackInfo():
  info = pq.GetCurrentTrackInfo()
  if (info):
    track = info['name']
    artist = m.GetArtistInfo(info['artists'][0])
    artist = artist['name']
    text = UnicodeToAscii("Track : " + track + " : " + artist)
    print text
    if (options.announce):
      synth.SpeakAndWaitUntilFinished(text)

# Main application loop
while True:

  # Wait for ASR command outcome in the form (outcome, probability)
  outcome = asr.WaitSpeechOutcome()

  # Try to gather outcome information
  if (outcome):
    intent = outcome.intent.name
    entities = outcome.entities
    print outcome
  else:
    intent = 'Uknown'
    entities = None

  if intent == 'play' and not entities:
    pq.Play()
    TrackInfo()
    NewTrackIndication()
  elif intent == 'stop':
    pq.Stop()
  elif intent == 'skip':
    pq.SkipForward()
    TrackInfo()
    NewTrackIndication()
  elif intent == 'back':
    pq.SkipBack()
    TrackInfo()
    NewTrackIndication()
  elif ((intent == 'search') or (intent == 'play' and entities) or
        (intent == 'find' and entities)):
    #try:
    q = SpotifySearch(entities, m, musicDb=db, offline=False)
    print "Submitting query..."
    results = q.GetQueryResults()
    #except:
    #  print "Was not able to format query", sys.exc_info()[0]
    #  results = []
    numTracks = len(results)
    print "Search returned", numTracks, "tracks..."
    if (intent == 'play' and numTracks > 0):
      print "Inserted", numTracks, "tracks onto playlist"
      pq.Insert(results)
      pq.Reset()
      pq.Play()
      TrackInfo()
      NewTrackIndication()
    elif (numTracks > 0):
      print "Appended", numTracks, "tracks onto playlist"
      pq.Append(results)
  elif intent == 'reset':
    pq.Reset()
  elif intent == 'clear':
    pq.Clear()
  elif intent == 'info':
    print "Play queue at", pq.QueueIndex(), "with", pq.QueueSize(), "tracks."
    TrackInfo()
  elif intent == 'insert':
    if (search):
      pq.Insert(search)
  elif intent == 'append':
    if (search):
      pq.Append(search)
  elif intent == 'stats':
    stats = m.GetStatistics()
    print "Occupancy:", stats[2], "%", "Dropped:", stats[1]
  elif intent == 'exit' or intent == 'quit':
    break

# Logout and delete session
m.LogoutUser()
m.Exit()
asr.Exit()
